

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      layouts/BaseLayout.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      Graph visualization
    </h3>

    
      <h3>
        Resources
      </h3>
      
        <a href="https://github.com/svgdotjs/svg.js">svgdotjs</a>
      
    

    <h3>Classes</h3><ul><li id="AssetNode-nav"><a href="AssetNode.html">AssetNode</a><ul class='methods'><li data-type="method" id="AssetNode-renderAsMax-nav"><a href="AssetNode.html#renderAsMax">renderAsMax</a></li><li data-type="method" id="AssetNode-renderAsMin-nav"><a href="AssetNode.html#renderAsMin">renderAsMin</a></li><li data-type="method" id="AssetNode-transformToMax-nav"><a href="AssetNode.html#transformToMax">transformToMax</a></li><li data-type="method" id="AssetNode-transformToMin-nav"><a href="AssetNode.html#transformToMin">transformToMin</a></li></ul></li><li id="BaseEdge-nav"><a href="BaseEdge.html">BaseEdge</a></li><li id="BaseNode-nav"><a href="BaseNode.html">BaseNode</a><ul class='methods'><li data-type="method" id="BaseNode-createIcon-nav"><a href="BaseNode.html#createIcon">createIcon</a></li><li data-type="method" id="BaseNode-createLabel-nav"><a href="BaseNode.html#createLabel">createLabel</a></li><li data-type="method" id="BaseNode-createNode-nav"><a href="BaseNode.html#createNode">createNode</a></li><li data-type="method" id="BaseNode-getConfig-nav"><a href="BaseNode.html#getConfig">getConfig</a></li><li data-type="method" id="BaseNode-getCurrentHeight-nav"><a href="BaseNode.html#getCurrentHeight">getCurrentHeight</a></li><li data-type="method" id="BaseNode-getCurrentWidth-nav"><a href="BaseNode.html#getCurrentWidth">getCurrentWidth</a></li><li data-type="method" id="BaseNode-getFinalX-nav"><a href="BaseNode.html#getFinalX">getFinalX</a></li><li data-type="method" id="BaseNode-getFinalY-nav"><a href="BaseNode.html#getFinalY">getFinalY</a></li><li data-type="method" id="BaseNode-getInitialX-nav"><a href="BaseNode.html#getInitialX">getInitialX</a></li><li data-type="method" id="BaseNode-getInitialY-nav"><a href="BaseNode.html#getInitialY">getInitialY</a></li><li data-type="method" id="BaseNode-setConfig-nav"><a href="BaseNode.html#setConfig">setConfig</a></li><li data-type="method" id="BaseNode-setFinalX-nav"><a href="BaseNode.html#setFinalX">setFinalX</a></li><li data-type="method" id="BaseNode-setFinalXY-nav"><a href="BaseNode.html#setFinalXY">setFinalXY</a></li><li data-type="method" id="BaseNode-setFinalY-nav"><a href="BaseNode.html#setFinalY">setFinalY</a></li><li data-type="method" id="BaseNode-setInitialX-nav"><a href="BaseNode.html#setInitialX">setInitialX</a></li><li data-type="method" id="BaseNode-setInitialXY-nav"><a href="BaseNode.html#setInitialXY">setInitialXY</a></li><li data-type="method" id="BaseNode-setInitialY-nav"><a href="BaseNode.html#setInitialY">setInitialY</a></li></ul></li><li id="ControlNode-nav"><a href="ControlNode.html">ControlNode</a><ul class='methods'><li data-type="method" id="ControlNode-renderAsMax-nav"><a href="ControlNode.html#renderAsMax">renderAsMax</a></li><li data-type="method" id="ControlNode-renderAsMin-nav"><a href="ControlNode.html#renderAsMin">renderAsMin</a></li><li data-type="method" id="ControlNode-transformToMax-nav"><a href="ControlNode.html#transformToMax">transformToMax</a></li><li data-type="method" id="ControlNode-transformToMin-nav"><a href="ControlNode.html#transformToMin">transformToMin</a></li></ul></li><li id="CustomNode-nav"><a href="CustomNode.html">CustomNode</a><ul class='methods'><li data-type="method" id="CustomNode-renderAsMax-nav"><a href="CustomNode.html#renderAsMax">renderAsMax</a></li><li data-type="method" id="CustomNode-renderAsMin-nav"><a href="CustomNode.html#renderAsMin">renderAsMin</a></li><li data-type="method" id="CustomNode-transformToMax-nav"><a href="CustomNode.html#transformToMax">transformToMax</a></li><li data-type="method" id="CustomNode-transformToMin-nav"><a href="CustomNode.html#transformToMin">transformToMin</a></li></ul></li><li id="EdgeFactory-nav"><a href="EdgeFactory.html">EdgeFactory</a></li><li id="NodeFactory-nav"><a href="NodeFactory.html">NodeFactory</a></li><li id="RequirementNode-nav"><a href="RequirementNode.html">RequirementNode</a><ul class='methods'><li data-type="method" id="RequirementNode-renderAsMax-nav"><a href="RequirementNode.html#renderAsMax">renderAsMax</a></li><li data-type="method" id="RequirementNode-renderAsMin-nav"><a href="RequirementNode.html#renderAsMin">renderAsMin</a></li><li data-type="method" id="RequirementNode-transformToMax-nav"><a href="RequirementNode.html#transformToMax">transformToMax</a></li><li data-type="method" id="RequirementNode-transformToMin-nav"><a href="RequirementNode.html#transformToMin">transformToMin</a></li></ul></li><li id="RiskNode-nav"><a href="RiskNode.html">RiskNode</a><ul class='methods'><li data-type="method" id="RiskNode-renderAsMax-nav"><a href="RiskNode.html#renderAsMax">renderAsMax</a></li><li data-type="method" id="RiskNode-renderAsMin-nav"><a href="RiskNode.html#renderAsMin">renderAsMin</a></li><li data-type="method" id="RiskNode-transformToMax-nav"><a href="RiskNode.html#transformToMax">transformToMax</a></li><li data-type="method" id="RiskNode-transformToMin-nav"><a href="RiskNode.html#transformToMin">transformToMin</a></li></ul></li><li id="Visualization-nav"><a href="Visualization.html">Visualization</a><ul class='methods'><li data-type="method" id="Visualization-getCanvas-nav"><a href="Visualization.html#getCanvas">getCanvas</a></li><li data-type="method" id="Visualization-render-nav"><a href="Visualization.html#render">render</a></li><li data-type="method" id="Visualization-setZoom-nav"><a href="Visualization.html#setZoom">setZoom</a></li><li data-type="method" id="Visualization-transform-nav"><a href="Visualization.html#transform">transform</a></li></ul></li></ul><h3 id="global-nav"><a href="global.html">Global</a></h3>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        layouts/BaseLayout.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>import RiskNode from "../nodes/RiskNode"
import AssetNode from "../nodes/AssetNode"
import RequirementNode from "../nodes/RequirementNode"
import CustomNode from "../nodes/CustomNode"
import ControlNode from "../nodes/ControlNode"
import ThinEdge from "../edges/ThinEdge"
import BoldEdge from "../edges/BoldEdge"


class BaseLayout {
  constructor() {
    this.canvas = null


    this.rawNodes = []
    this.rawEdges = []

    this.nodes = []
    this.edges = []
    this.leafs = []

    this.currentLayoutWidth = 0
    this.currentLayoutHeight = 0

    this.info = {
      currentX: 0,
      currentY: 0,
      currentWidth: 0,
      currentHeight: 0,
      currentState: "expanded",
    }

    this.tree = null
  }

  getNodeData() {
    return this.nodeData
  }

  getEdgeData() {
    return this.edgeData
  }

  async createGridDataAsync(nodeData, edgeData) {
    this.nodeData = nodeData
    this.edgeData = edgeData


    // find children ids that we need to fetch
    const mapNodeIdsToUrl = (n) => `id=${n.id}&amp;`
    const nodeIdsToFetch = nodeData.map(mapNodeIdsToUrl).join("").slice(0, -1)
    const nodeFetchUrl = `${this.config.databaseUrl}/nodes?${nodeIdsToFetch}`
    const fetchedNodes = await fetch(nodeFetchUrl).then((data) => data.json())


    // create new nodes
    fetchedNodes.forEach((rawNode) => {
      let node
      if (rawNode.type === "risk") node = new RiskNode(rawNode, this.canvas)
      if (rawNode.type === "asset") node = new AssetNode(rawNode, this.canvas)
      if (rawNode.type === "custom") node = new CustomNode(rawNode, this.canvas)
      if (rawNode.type === "requirement") node = new RequirementNode(rawNode, this.canvas)
      if (rawNode.type === "control") node = new ControlNode(rawNode, this.canvas)

      // sets the currently used rendering size
      node.setNodeSize(this.config.renderingSize)
      // node.addEvent("dblclick", () => { this.manageTreeDataAsync(node) })

      this.nodes.push(node)
    })


    // re-calculate and re-render layout
    this.calculateLayout()
    this.renderLayout()
  }


  /**
   * Contextual layout data creation
   * @param {*} nodeData
   * @param {*} edgeData
   */
  async createContextualDataAsync(nodeData, edgeData) {
    this.nodeData = nodeData
    this.edgeData = edgeData


    // in order to load parents and children, the data of the focus node has to be loaded first
    const focusNode = this.nodeData.find((n) => n.id === this.startNodeId)
    const focusFetchUrl = `${this.config.databaseUrl}/nodes?id=${focusNode.id}`
    const fetchedFocus = await fetch(focusFetchUrl).then((data) => data.json())
    this.createNodeFromData(fetchedFocus[0], "max")
    this.focus = this.nodes.find((n) => n.id === this.startNodeId)


    // load parents and children passed on edges inside the graph structure
    const parentChildNodeIds = this.edgeData.map((e) => {
      if (e.startNodeId === this.startNodeId) {
        return e.endNodeId
      }
      if (e.endNodeId === this.startNodeId) {
        return e.startNodeId
      }
      return null
    }).filter((id) => id !== null)
    const mapNodeIdsToUrl = (id) => `id=${id}&amp;`
    const nodeIdsToFetch = parentChildNodeIds.map(mapNodeIdsToUrl).join("").slice(0, -1)
    const nodeFetchUrl = `${this.config.databaseUrl}/nodes?${nodeIdsToFetch}`
    const fetchedNodes = await fetch(nodeFetchUrl).then((data) => data.json())

    fetchedNodes.forEach((rawNode) => {
      this.createNodeFromData(rawNode, "min")
    })
    const parentNodeIds = this.edgeData.filter((e) => e.startNodeId === this.startNodeId).map((e) => e.endNodeId)
    const childNodeIds = this.edgeData.filter((e) => e.endNodeId === this.startNodeId).map((e) => e.startNodeId)
    this.parents = this.nodes.filter((n) => parentNodeIds.includes(n.id))
    this.children = this.nodes.filter((n) => childNodeIds.includes(n.id))


    // here we load attached risks which are attached to a different node
    const assignedNodeDataUrl = `${this.config.databaseUrl}/RiskEdgeConnectionTable?startNodeId=${this.startNodeId}`
    const assignedNodeData = await fetch(assignedNodeDataUrl).then((data) => data.json())
    const assignedNodeId = assignedNodeData[0].endNodeId
    const riskIds = assignedNodeData[0].risks

    const assignedNodeUrl = `${this.config.databaseUrl}/nodes?id=${assignedNodeId}`
    const assignedNode = await fetch(assignedNodeUrl).then((data) => data.json())
    this.createNodeFromData(assignedNode[0], "min")
    this.assginedNode = this.nodes.find((n) => n.id === assignedNodeId)

    const riskIdsToFetch = riskIds.map(mapNodeIdsToUrl).join("").slice(0, -1)
    const riskFetchUrl = `${this.config.databaseUrl}/nodes?${riskIdsToFetch}`
    const fetchedRisks = await fetch(riskFetchUrl).then((data) => data.json())

    fetchedRisks.forEach((rawNode) => {
      this.createNodeFromData(rawNode, "min")
    })
    this.risks = this.nodes.filter((n) => riskIds.includes(n.id))
    const config = {
      color1: "#F26A7C", color2: "#F26A7C", labelTranslateY: -20, labelColor: "#ff8e9e",
    }
    const connection = new BoldEdge(this.canvas, this.focus, this.assginedNode, config)
    connection.setLabel("associated")
    this.edges.push(connection)


    // load edges
    const parentChildEdges = this.edgeData.filter((e) => {
      if (e.startNodeId === this.startNodeId) {
        return true
      }
      if (e.endNodeId === this.startNodeId) {
        return true
      }
      return false
    })

    // fetch edges based on given ids
    const mapEdgeIdsToUrl = (n) => `endNodeId=${n.endNodeId}&amp;startNodeId=${n.startNodeId}&amp;`
    const edgeIdsToFetch = parentChildEdges.map(mapEdgeIdsToUrl).join("").slice(0, -1)
    const edgeFetchUrl = `${this.config.databaseUrl}/edges?${edgeIdsToFetch}`
    const fetchedEdges = await fetch(edgeFetchUrl).then((data) => data.json())

    // create new edges
    fetchedEdges.forEach((rawEdge) => {
      const fromNode = this.nodes.find((n) => n.id === rawEdge.startNodeId)
      const toNode = this.nodes.find((n) => n.id === rawEdge.endNodeId)

      let edge = null
      if (rawEdge.type === "solid") edge = new ThinEdge(this.canvas, fromNode, toNode, { type: "solid" })
      else if (rawEdge.type === "dashed") edge = new ThinEdge(this.canvas, fromNode, toNode, { type: "dashed" })
      else if (rawEdge.type === "bold") edge = new BoldEdge(this.canvas, fromNode, toNode, { type: "bold" })
      else edge = new ThinEdge(this.canvas, fromNode, toNode, { type: "solid" })

      fromNode.addOutgoingEdge(edge)
      toNode.addIncomingEdge(edge)
      edge.setLabel(rawEdge.label)
      this.edges.push(edge)
    })


    // re-calculate and re-render layout
    this.calculateLayout()
    this.renderLayout()
  }

  async manageContextualDataAsync(clickedNode) {
    // remove all elements but the clicked node
    const removedNodes = []
    const nodesToRemove = this.nodes // .filter((n) => n.id !== clickedNode.id)
    const X = this.focus.getFinalX()
    const Y = this.focus.getFinalY()

    // remove children
    nodesToRemove.forEach((child) => {
      child.removeNode(X, Y)
      removedNodes.push(child.id)
    })
    clickedNode.setChildren([])
    // this.nodes = this.nodes.filter((node) => !removedNodes.includes(node.id))
    this.nodes = []


    // remove containers
    this.containers.forEach((container) => {
      container.removeContainer(X, Y)
    })
    this.containers = []

    // remove edges
    this.edges.forEach((edge) => {
      edge.removeEdge(X, Y)
    })
    this.edges = []

    // transform clicked node into max and position it to focus
    // clickedNode.setInitialXY(clickedNode.getFinalX(), clickedNode.getFinalY())
    // clickedNode.transformToMax(X, Y)


    // clear layout
    this.focus = null
    this.parents = []
    this.children = []
    this.assginedNode = null
    this.assignedRisks = []
    this.containers = []

    // this.nodes[0].transformToMax(X, Y)


    // // add data

    this.startNodeId = clickedNode.id
    this.createContextualDataAsync(this.nodeData, this.edgeData)

    // // in order to load parents and children, the data of the focus node has to be loaded first
    // const focusFetchUrl = `${this.config.databaseUrl}/nodes?id=${clickedNode.getId()}`
    // const fetchedFocus = await fetch(focusFetchUrl).then((data) => data.json())
    // console.log(fetchedFocus[0])
    // this.createNodeFromData(fetchedFocus[0], "max")
    // this.focus = this.nodes.find((n) => n.id === fetchedFocus[0].id)


    // // load parents and children edges
    // const parentEdgeFetchUrl = `${this.config.databaseUrl}/edges?startNodeId=${fetchedFocus[0].id}`
    // const childrenEdgeFetchUrl = `${this.config.databaseUrl}/edges?endNodeId=${fetchedFocus[0].id}`
    // const fetchedParentEdges = await fetch(parentEdgeFetchUrl).then((data) => data.json())
    // const fetchedChildrenEdges = await fetch(childrenEdgeFetchUrl).then((data) => data.json())
    // const fetchedEdges = [...fetchedChildrenEdges, ...fetchedParentEdges]


    // // load nodes based on edngNodeIds in edge response
    // const nodeIds = fetchedEdges.map((e) => e.endNodeId)
    // const mapNodeIdsToUrl = (id) => `id=${id}&amp;`
    // const nodeIdsToFetch = nodeIds.map(mapNodeIdsToUrl).join("").slice(0, -1)
    // const nodeFetchUrl = `${this.config.databaseUrl}/nodes?${nodeIdsToFetch}`
    // const fetchedNodes = await fetch(nodeFetchUrl).then((data) => data.json())
    // fetchedNodes.forEach((rawNode) => {
    //   this.createNodeFromData(rawNode, "min")
    // })
    // // console.log(fetchedEdges)

    // const parentNodeIds = fetchedEdges.filter((e) => e.endNodeId !== clickedNode.id).map((n) => n.endNodeId)
    // const childNodeIds = fetchedEdges.filter((e) => e.startNodeId !== clickedNode.id).map((n) => n.startNodeId)
    // this.parents = this.nodes.filter((n) => parentNodeIds.includes(n.id))
    // this.children = this.nodes.filter((n) => childNodeIds.includes(n.id))
    // console.log(childNodeIds, this.nodes)
    // // // this.parents = this.nodes.filter((n) => parentNodeIds.includes(n.id))
    // // // this.children = this.nodes.filter((n) => childNodeIds.includes(n.id))


    // create new edges
    // fetchedEdges.forEach((rawEdge) => {
    //   const fromNode = this.nodes.find((n) => n.id === rawEdge.startNodeId)
    //   const toNode = this.nodes.find((n) => n.id === rawEdge.endNodeId)

    //   let edge = null
    //   if (rawEdge.type === "solid") edge = new ThinEdge(this.canvas, fromNode, toNode, { type: "solid" })
    //   else if (rawEdge.type === "dashed") edge = new ThinEdge(this.canvas, fromNode, toNode, { type: "dashed" })
    //   else if (rawEdge.type === "bold") edge = new BoldEdge(this.canvas, fromNode, toNode, { type: "bold" })
    //   else edge = new ThinEdge(this.canvas, fromNode, toNode, { type: "solid" })

    //   fromNode.addOutgoingEdge(edge)
    //   toNode.addIncomingEdge(edge)
    //   edge.setLabel(rawEdge.label)
    //   this.edges.push(edge)
    // })

    // load parents and children passed on those edges
    // console.log(fetchedEdges)
  }

  createNodeFromData(data, renderingSize) {
    let node
    if (data.type === "risk") node = new RiskNode(data, this.canvas)
    if (data.type === "asset") node = new AssetNode(data, this.canvas)
    if (data.type === "custom") node = new CustomNode(data, this.canvas)
    if (data.type === "requirement") node = new RequirementNode(data, this.canvas)
    if (data.type === "control") node = new ControlNode(data, this.canvas)

    // sets the currently used rendering size
    node.setNodeSize(renderingSize)
    if (data.type === "control") {
      node.addEvent("dblclick", () => { this.manageContextualDataAsync(node) })
    }

    this.nodes.push(node)
  }


  async createRadialDataAsync(nodeData, edgeData) { // FIXME: ask: what if an edge dose not exist?
    this.nodeData = nodeData
    this.edgeData = edgeData


    // find children ids that we need to fetch
    const mapNodeIdsToUrl = (n) => `id=${n.id}&amp;`
    const nodeIdsToFetch = nodeData.map(mapNodeIdsToUrl).join("").slice(0, -1)
    const nodeFetchUrl = `${this.config.databaseUrl}/nodes?${nodeIdsToFetch}`
    const fetchedNodes = await fetch(nodeFetchUrl).then((data) => data.json())


    // create new nodes
    fetchedNodes.forEach((rawNode) => {
      let node
      if (rawNode.type === "risk") node = new RiskNode(rawNode, this.canvas)
      if (rawNode.type === "asset") node = new AssetNode(rawNode, this.canvas)
      if (rawNode.type === "custom") node = new CustomNode(rawNode, this.canvas)
      if (rawNode.type === "requirement") node = new RequirementNode(rawNode, this.canvas)
      if (rawNode.type === "control") node = new ControlNode(rawNode, this.canvas)

      // sets the currently used rendering size
      node.setNodeSize(this.config.renderingSize)
      node.addEvent("dblclick", () => { this.manageTreeDataAsync(node) })

      this.nodes.push(node)
    })


    // construct a tree data structure to generate edges and calculate node positions
    const constructTree = (array, parentRef, rootRef) => {
      let root = rootRef !== undefined ? rootRef : []
      const parent = parentRef !== undefined ? parentRef : { id: null }
      const children = array.filter((child) => child.parentId === parent.id)
      if (children.length > 0) {
        if (parent.id === null) {
          root = children
        } else {
          parent.children = children
        }

        children.forEach((child) => {
          constructTree(array, child)
        })
      }
      return root
    }
    const tree = constructTree(fetchedNodes)[0] // FIXME: where is the root?


    // find edges that the layout needs
    const createEdges = (root, edgeList) => {
      if (root.children) {
        root.children.forEach((child) => {
          edgeList.push({ startNodeId: child.id, endNodeId: root.id })
          createEdges(child, edgeList)
        })
      }
      return edgeList
    }
    const requiredEdges = [...new Set(createEdges(tree, []))]


    // fetch edges based on given ids
    const mapEdgeIdsToUrl = (n) => `endNodeId=${n.endNodeId}&amp;startNodeId=${n.startNodeId}&amp;`
    const edgeIdsToFetch = requiredEdges.map(mapEdgeIdsToUrl).join("").slice(0, -1)
    const edgeFetchUrl = `${this.config.databaseUrl}/edges?${edgeIdsToFetch}`
    const fetchedEdges = await fetch(edgeFetchUrl).then((data) => data.json())


    // create new edges
    fetchedEdges.forEach((rawEdge) => {
      const fromNode = this.nodes.find((n) => n.id === rawEdge.startNodeId)
      const toNode = this.nodes.find((n) => n.id === rawEdge.endNodeId)


      let edge = null
      if (rawEdge.type === "solid") edge = new ThinEdge(this.canvas, fromNode, toNode, { type: "solid" })
      else if (rawEdge.type === "dashed") edge = new ThinEdge(this.canvas, fromNode, toNode, { type: "dashed" })
      else if (rawEdge.type === "bold") edge = new BoldEdge(this.canvas, fromNode, toNode, { type: "bold" })
      else edge = new ThinEdge(this.canvas, fromNode, toNode, { type: "solid" })

      fromNode.addOutgoingEdge(edge)
      toNode.addIncomingEdge(edge)
      edge.setLabel(rawEdge.label)
      this.edges.push(edge)
    })


    // re-calculate and re-render layout
    this.calculateLayout()
    this.renderLayout()
  }


  async manageTreeDataAsync(clickedNode) {
    const BFS = (root) => {
      const remove = []
      const queue = []

      queue.push(root)


      while (queue.length) {
        const current = queue.shift()
        if (current.id !== root.id) {
          remove.push(current)
        }

        current.children.forEach((child) => {
          if (!queue.includes(child)) {
            queue.push(child)
          }
        })
      }

      return remove
    }

    // skip, if node has no children
    if (clickedNode.childrenIds.length === 0) {
      return
    }


    const isAddOperation = clickedNode.children.map((child) => child.svg).length === 0

    // add new data
    if (isAddOperation) {
      // find children ids that we need to fetch
      const requestedNodes = []
      const existingNodes = this.nodes.map((n) => n.id)
      clickedNode.childrenIds.forEach((id) => {
        if (!existingNodes.includes(id)) {
          requestedNodes.push(id)
        }
      })

      // remove leafs (tree specific)
      this.leafs.forEach((leafe) => {
        leafe.removeLeaf(clickedNode.getFinalX(), clickedNode.getFinalY())
      })
      this.leafs = []


      // fetch children based on given ids
      const mapNodeIdsToUrl = (id) => `id=${id}&amp;`
      const nodeIdsToFetch = requestedNodes.map(mapNodeIdsToUrl).join("").slice(0, -1)
      const nodeFetchUrl = `${this.config.databaseUrl}/nodes?${nodeIdsToFetch}`
      const fetchedNodes = await fetch(nodeFetchUrl).then((data) => data.json())


      // create new children nodes
      fetchedNodes.forEach((rawNode) => {
        let node
        if (rawNode.type === "risk") node = new RiskNode(rawNode, this.canvas)
        if (rawNode.type === "asset") node = new AssetNode(rawNode, this.canvas)
        if (rawNode.type === "custom") node = new CustomNode(rawNode, this.canvas)
        if (rawNode.type === "requirement") node = new RequirementNode(rawNode, this.canvas)
        if (rawNode.type === "control") node = new ControlNode(rawNode, this.canvas)

        // sets the currently used rendering size
        node.setNodeSize(this.config.renderingSize)
        node.addEvent("dblclick", () => { this.manageTreeDataAsync(node) })

        this.nodes.push(node)
      })


      // find edges between new children and clicked node
      const requiredEdges = []
      fetchedNodes.forEach((node) => {
        requiredEdges.push({ startNodeId: node.id, endNodeId: clickedNode.id })
      })


      // fetch edges based on given ids
      const mapEdgeIdsToUrl = (n) => `endNodeId=${n.endNodeId}&amp;startNodeId=${n.startNodeId}&amp;`
      const edgeIdsToFetch = requiredEdges.map(mapEdgeIdsToUrl).join("").slice(0, -1)
      const edgeFetchUrl = `${this.config.databaseUrl}/edges?${edgeIdsToFetch}`
      const fetchedEdges = await fetch(edgeFetchUrl).then((data) => data.json())


      // create new edges
      fetchedEdges.forEach((rawEdge) => {
        const fromNode = this.nodes.find((n) => n.id === rawEdge.startNodeId)
        const toNode = this.nodes.find((n) => n.id === rawEdge.endNodeId)


        let edge = null
        if (rawEdge.type === "solid") edge = new ThinEdge(this.canvas, fromNode, toNode, { type: "solid" })
        else if (rawEdge.type === "dashed") edge = new ThinEdge(this.canvas, fromNode, toNode, { type: "dashed" })
        else if (rawEdge.type === "bold") edge = new BoldEdge(this.canvas, fromNode, toNode, { type: "bold" })
        else edge = new ThinEdge(this.canvas, fromNode, toNode, { type: "solid" })

        fromNode.addOutgoingEdge(edge)
        toNode.addIncomingEdge(edge)
        edge.setLabel(rawEdge.label)
        this.edges.push(edge)
      })


      // re-calculate and re-render layout
      this.calculateLayout()
      this.renderLayout()
    }

    // remove existing data
    if (isAddOperation === false) {
      // find children ids that we need to remove
      const removedNodes = []
      const nodesToRemove = BFS(clickedNode)
      const X = clickedNode.getFinalX()
      const Y = clickedNode.getFinalY()


      // remove children
      nodesToRemove.forEach((child) => {
        child.removeNode(X, Y)
        removedNodes.push(child.id)
      })
      clickedNode.setChildren([])
      this.nodes = this.nodes.filter((node) => !removedNodes.includes(node.id))


      // find edges that we need to remove
      const edgesToRemove = [...nodesToRemove.map((n) => n.outgoingEdges)].flat()
      const edgesToBeUpdated = []
      this.edges.forEach((edge) => {
        if (edgesToRemove.includes(edge) === false) {
          edgesToBeUpdated.push(edge)
        }
      })


      // remove edges
      edgesToRemove.forEach((edge) => {
        edge.removeEdge(clickedNode.getFinalX(), clickedNode.getFinalY())
      })
      this.edges = []
      this.edges = [...edgesToBeUpdated]


      // remove leafs (tree specific)
      this.leafs.forEach((leafe) => {
        leafe.removeLeaf(clickedNode.getFinalX(), clickedNode.getFinalY())
      })
      this.leafs = []

      // re-calculate and re-render layout
      this.calculateLayout()
      this.renderLayout()


      // update existing edges
      this.edges.forEach((edge) => {
        edge.updateEdgePosition()
      })
    }
  }

  removeLayout() {
    this.nodes.forEach((node) => {
      node.removeNode()
    })

    this.edges.forEach((edge) => {
      edge.removeEdge()
    })

    this.leafs.forEach((leaf) => {
      leaf.removeLeaf()
    })
  }


  setConfig(config) {
    this.config = { ...this.config, ...config }
  }

  setCanvas(canvas) {
    this.canvas = canvas.nested()
  }

  setRawNodes(rawNodes) {
    this.rawNodes = [...rawNodes]
  }

  setRawEdges(rawEdges) {
    this.rawEdges = [...rawEdges]
  }


  setNodes(nodes) {
    this.nodes = nodes
  }

  getNodes() {
    return this.nodes
  }

  getEdges() {
    return this.edges
  }

  setEdges(edges) {
    this.edges = edges
  }
}


export default BaseLayout
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>
